<!doctype html>
<html>
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>30s Voice Recorder</title>
  <style>
    body { font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto; max-width:600px; margin:40px auto; padding:20px; }
    button { padding:12px 18px; margin:6px; font-size:16px; }
    .timer { font-size:18px; margin-top:8px; }
    audio { display:block; margin-top:10px; width:100%; }
    .status { margin-top:8px; color: #333; }
  </style>
</head>
<body>
  <h2>30s Voice Recorder</h2>
  <div>
    <button id="recordBtn">Record</button>
    <button id="pauseBtn" disabled>Pause</button>
    <button id="stopBtn" disabled>Stop</button>
    <button id="resetBtn" disabled>Record Again</button>
  </div>
  <div class="timer" id="timer">00:00 / 00:30</div>
  <audio id="player" controls></audio>
  <div style="margin-top:12px">
    <button id="uploadBtn" disabled>Upload to Drive</button>
  </div>
  <div class="status" id="status"></div>

<script>
const APP_URL = 'YOUR_WEB_APP_URL_HERE'; // paste Apps Script URL
const SECRET = 'YOUR_SECRET_TOKEN_HERE'; // keep in sync with Apps Script
const MAX_SECONDS = 30;

let mediaRecorder, audioStream, chunks = [];
let recordedBlob = null;
let timerInterval = null, seconds = 0;
const recordBtn = document.getElementById('recordBtn');
const pauseBtn = document.getElementById('pauseBtn');
const stopBtn = document.getElementById('stopBtn');
const resetBtn = document.getElementById('resetBtn');
const uploadBtn = document.getElementById('uploadBtn');
const player = document.getElementById('player');
const statusEl = document.getElementById('status');
const timerEl = document.getElementById('timer');

function updateTimer() {
  seconds++;
  if (seconds >= MAX_SECONDS) {
    stopRecording();
  }
  const mm = String(Math.floor(seconds / 60)).padStart(2,'0');
  const ss = String(seconds % 60).padStart(2,'0');
  timerEl.textContent = `${mm}:${ss} / 00:30`;
}

async function startRecording() {
  if (!navigator.mediaDevices || !navigator.mediaDevices.getUserMedia) {
    alert('getUserMedia not supported. Use an up-to-date iPadOS/Safari.');
    return;
  }
  try {
    audioStream = await navigator.mediaDevices.getUserMedia({ audio: true });
    const options = { mimeType: 'audio/webm' };
    mediaRecorder = new MediaRecorder(audioStream, options);
  } catch (err) {
    statusEl.textContent = 'Microphone access denied or unsupported: ' + err.message;
    return;
  }

  chunks = [];
  seconds = 0;
  timerEl.textContent = '00:00 / 00:30';
  timerInterval = setInterval(updateTimer, 1000);

  mediaRecorder.ondataavailable = e => {
    if (e.data && e.data.size > 0) chunks.push(e.data);
  };
  mediaRecorder.onstop = () => {
    recordedBlob = new Blob(chunks, { type: chunks[0] ? chunks[0].type : 'audio/webm' });
    player.src = URL.createObjectURL(recordedBlob);
    uploadBtn.disabled = false;
    resetBtn.disabled = false;
    pauseBtn.disabled = true;
    stopBtn.disabled = true;
    recordBtn.textContent = 'Record';
    statusEl.textContent = 'Recording ready. Play or upload.';
    if (audioStream) {
      audioStream.getTracks().forEach(t => t.stop());
      audioStream = null;
    }
    clearInterval(timerInterval);
  };

  mediaRecorder.start();
  statusEl.textContent = 'Recording...';
  recordBtn.textContent = 'Recording...';
  recordBtn.disabled = true;
  pauseBtn.disabled = false;
  stopBtn.disabled = false;
}

function pauseResume() {
  if (!mediaRecorder) return;
  if (mediaRecorder.state === 'recording' && mediaRecorder.pause) {
    mediaRecorder.pause();
    pauseBtn.textContent = 'Resume';
    clearInterval(timerInterval);
    statusEl.textContent = 'Paused';
  } else if (mediaRecorder.state === 'paused' && mediaRecorder.resume) {
    mediaRecorder.resume();
    pauseBtn.textContent = 'Pause';
    timerInterval = setInterval(updateTimer, 1000);
    statusEl.textContent = 'Recording...';
  } else {
    // some browsers don't support pause/resume; just toggle stop/start as fallback
  }
}

function stopRecording() {
  if (mediaRecorder && (mediaRecorder.state === 'recording' || mediaRecorder.state === 'paused')) {
    mediaRecorder.stop();
  }
}

function resetRecording() {
  recordedBlob = null;
  chunks = [];
  player.src = '';
  uploadBtn.disabled = true;
  resetBtn.disabled = true;
  statusEl.textContent = '';
  timerEl.textContent = '00:00 / 00:30';
}

async function blobToBase64(blob) {
  return await new Promise((resolve, reject) => {
    const reader = new FileReader();
    reader.onloadend = () => {
      // result like "data:audio/webm;base64,AAAA..."
      const s = reader.result.split(',')[1];
      resolve(s);
    };
    reader.onerror = reject;
    reader.readAsDataURL(blob);
  });
}

async function upload() {
  if (!recordedBlob) return;
  statusEl.textContent = 'Preparing upload...';
  uploadBtn.disabled = true;

  try {
    const base64 = await blobToBase64(recordedBlob);
    const payload = {
      secret: SECRET,
      filename: 'recording_' + new Date().toISOString() + (recordedBlob.type.includes('ogg') ? '.ogg' : '.webm'),
      mimeType: recordedBlob.type || 'audio/webm',
      data: base64
    };

    const res = await fetch(APP_URL, {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify(payload)
    });

    const json = await res.json();
    if (json.status === 'success') {
      statusEl.innerHTML = 'Uploaded! <a href="' + json.url + '" target="_blank">Open in Drive</a>';
    } else {
      statusEl.textContent = 'Upload failed: ' + (json.message || JSON.stringify(json));
      uploadBtn.disabled = false;
    }
  } catch (err) {
    statusEl.textContent = 'Upload error: ' + err.message;
    uploadBtn.disabled = false;
  }
}

// UI wiring
recordBtn.addEventListener('click', () => {
  if (!mediaRecorder || mediaRecorder.state === 'inactive') startRecording();
});
pauseBtn.addEventListener('click', pauseResume);
stopBtn.addEventListener('click', stopRecording);
resetBtn.addEventListener('click', resetRecording);
uploadBtn.addEventListener('click', upload);
</script>
</body>
</html>
