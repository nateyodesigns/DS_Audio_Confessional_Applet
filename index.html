<!doctype html>
<html>
<head>

<link rel="preconnect" href="https://fonts.googleapis.com">
<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
<link href="https://fonts.googleapis.com/css2?family=Bree+Serif&family=IBM+Plex+Mono:ital,wght@0,100;0,200;0,300;0,400;0,500;0,600;0,700;1,100;1,200;1,300;1,400;1,500;1,600;1,700&display=swap" rel="stylesheet">
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Confessional of Future Dreams</title>
  <script src="https://cdn.jsdelivr.net/npm/lamejs@1.2.1/lame.min.js"></script>
  <style>

.instrument-serif-regular {
  font-family: "Instrument Serif", serif;
  font-weight: 400;
  font-style: normal;
}

.instrument-serif-regular-italic {
  font-family: "Instrument Serif", serif;
  font-weight: 400;
  font-style: italic;
}



    body {
      font-family: "IBM Plex Mono", monospace;
      background: url('https://i-p.rmcdn.net/6564f807fd804900278f36db/5175659/image-252d07f8-1150-4519-a6fe-f76626da04c4.png?e=webp&nll=true&cX=0&cY=108&cW=1978&cH=881') no-repeat center center fixed;
      background-size: cover;
      color: white;
      text-align: center;
      padding: 40px;
    }
    h2 { font-size: 26px; margin-bottom: 20px; }
    button {
      font-family: "IBM Plex Mono", monospace;
      background: rgba(255,255,255,0.15);
      color: white;
      border: 1px solid rgba(255,255,255,0.4);
      padding: 12px 18px;
      margin: 6px;
      font-size: 16px;
      border-radius: 10px;
      cursor: pointer;
      transition: all 0.2s ease;
      backdrop-filter: blur(5px);
    }
    button:hover:not(:disabled) {
      background: rgba(255,255,255,0.25);
    }
    button:disabled {
      opacity: 0.4;
      cursor: default;
    }
    .timer { font-size: 18px; margin-top: 12px; }
    audio { display: block; margin: 20px auto; width: 100%; max-width: 400px; }
    .status { margin-top: 12px; font-size: 17px; }
  </style>
</head>
<body>
  <h2>Confessional of Future Dreams</h2>

  <div>
    <button id="recordBtn">Record</button>
    <button id="pauseBtn" disabled>Pause</button>
    <button id="stopBtn" disabled>Stop</button>
    <button id="resetBtn" disabled>Record Again</button>
  </div>

  <div class="timer" id="timer">00:00 / 00:30</div>
  <audio id="player" controls></audio>

  <div style="margin-top:12px">
    <button id="submitBtn" disabled>Submit My Future Dream</button>
  </div>

  <div class="status" id="status"></div>

<script>
const MAX_SECONDS = 30;
let mediaRecorder, audioStream, chunks = [];
let recordedBlob = null, timerInterval = null, seconds = 0;

const recordBtn = document.getElementById('recordBtn');
const pauseBtn = document.getElementById('pauseBtn');
const stopBtn = document.getElementById('stopBtn');
const resetBtn = document.getElementById('resetBtn');
const submitBtn = document.getElementById('submitBtn');
const player = document.getElementById('player');
const statusEl = document.getElementById('status');
const timerEl = document.getElementById('timer');

function updateTimer() {
  seconds++;
  if (seconds >= MAX_SECONDS) stopRecording();
  const mm = String(Math.floor(seconds / 60)).padStart(2,'0');
  const ss = String(seconds % 60).padStart(2,'0');
  timerEl.textContent = `${mm}:${ss} / 00:30`;
}

async function startRecording() {
  if (!navigator.mediaDevices || !navigator.mediaDevices.getUserMedia) {
    alert('Microphone not supported on this device.');
    return;
  }
  try {
    audioStream = await navigator.mediaDevices.getUserMedia({ audio: true });
    mediaRecorder = new MediaRecorder(audioStream);
  } catch (err) {
    statusEl.textContent = 'Microphone access denied: ' + err.message;
    return;
  }

  chunks = [];
  seconds = 0;
  timerInterval = setInterval(updateTimer, 1000);
  mediaRecorder.ondataavailable = e => chunks.push(e.data);
  mediaRecorder.onstop = convertToMp3;

  mediaRecorder.start();
  statusEl.textContent = 'Recording...';
  recordBtn.disabled = true;
  pauseBtn.disabled = false;
  stopBtn.disabled = false;
  resetBtn.disabled = true;
  submitBtn.disabled = true;
}

function pauseResume() {
  if (!mediaRecorder) return;
  if (mediaRecorder.state === 'recording') {
    mediaRecorder.pause();
    pauseBtn.textContent = 'Resume';
    clearInterval(timerInterval);
    statusEl.textContent = 'Paused';
  } else if (mediaRecorder.state === 'paused') {
    mediaRecorder.resume();
    pauseBtn.textContent = 'Pause';
    timerInterval = setInterval(updateTimer, 1000);
    statusEl.textContent = 'Recording...';
  }
}

function stopRecording() {
  if (mediaRecorder && (mediaRecorder.state === 'recording' || mediaRecorder.state === 'paused')) {
    mediaRecorder.stop();
    clearInterval(timerInterval);
    pauseBtn.disabled = true;
    stopBtn.disabled = true;
  }
}

function resetRecording() {
  recordedBlob = null;
  chunks = [];
  player.src = '';
  submitBtn.disabled = true;
  resetBtn.disabled = true;
  recordBtn.disabled = false;
  pauseBtn.disabled = true;
  stopBtn.disabled = true;
  statusEl.textContent = '';
  timerEl.textContent = '00:00 / 00:30';
}

async function convertToMp3() {
  const blob = new Blob(chunks, { type: 'audio/webm' });
  const arrayBuffer = await blob.arrayBuffer();
  const audioCtx = new AudioContext();
  const decoded = await audioCtx.decodeAudioData(arrayBuffer);
  const channelData = decoded.getChannelData(0);

  const mp3encoder = new lamejs.Mp3Encoder(1, decoded.sampleRate, 128);
  const samples = new Int16Array(channelData.length);
  for (let i = 0; i < channelData.length; i++) {
    samples[i] = channelData[i] * 32767;
  }
  const mp3Data = [];
  const chunkSize = 1152;
  for (let i = 0; i < samples.length; i += chunkSize) {
    const sampleChunk = samples.subarray(i, i + chunkSize);
    const mp3buf = mp3encoder.encodeBuffer(sampleChunk);
    if (mp3buf.length > 0) mp3Data.push(mp3buf);
  }
  const end = mp3encoder.flush();
  if (end.length > 0) mp3Data.push(end);

  recordedBlob = new Blob(mp3Data, { type: 'audio/mp3' });
  player.src = URL.createObjectURL(recordedBlob);
  statusEl.textContent = 'Your Future Dream is ready for the time capsule.';
  submitBtn.disabled = false;
  resetBtn.disabled = false;
  recordBtn.textContent = 'Record';
  recordBtn.disabled = false;
  pauseBtn.textContent = 'Pause';
  if (audioStream) audioStream.getTracks().forEach(t => t.stop());
}

function submitAndReset() {
  if (!recordedBlob) return;
  const a = document.createElement('a');
  a.href = URL.createObjectURL(recordedBlob);
  a.download = 'MyFutureDream.mp3';
  document.body.appendChild(a);
  a.click();
  document.body.removeChild(a);

  statusEl.textContent = 'Thank you for submitting!';
  submitBtn.disabled = true;
  setTimeout(resetRecording, 5000);
}

// Button wiring
recordBtn.addEventListener('click', startRecording);
pauseBtn.addEventListener('click', pauseResume);
stopBtn.addEventListener('click', stopRecording);
resetBtn.addEventListener('click', resetRecording);
submitBtn.addEventListener('click', submitAndReset);
</script>
</body>
</html>
