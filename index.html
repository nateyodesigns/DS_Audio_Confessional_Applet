<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>30s Voice Recorder</title>
  <style>
    body { 
      font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto; 
      max-width: 600px; 
      margin: 40px auto; 
      padding: 20px; 
      text-align: center; 
    }
    button { 
      padding: 12px 18px; 
      margin: 6px; 
      font-size: 16px; 
      border-radius: 8px; 
      border: none; 
      background: #333; 
      color: white; 
      cursor: pointer;
    }
    button:disabled {
      opacity: 0.5;
      cursor: not-allowed;
    }
    .timer { font-size: 18px; margin-top: 8px; }
    audio { display:block; margin-top: 10px; width:100%; }
    .status { margin-top: 12px; color: #333; }
  </style>
</head>
<body>
  <h2>üéôÔ∏è 30s Voice Recorder</h2>
  <div>
    <button id="recordBtn">Record</button>
    <button id="pauseBtn" disabled>Pause</button>
    <button id="stopBtn" disabled>Stop</button>
    <button id="resetBtn" disabled>Record Again</button>
  </div>
  <div class="timer" id="timer">00:00 / 00:30</div>
  <audio id="player" controls></audio>
  <div style="margin-top:12px">
    <button id="uploadBtn" disabled>Upload to Drive</button>
  </div>
  <div class="status" id="status"></div>

<script>
const APP_URL = 'https://script.google.com/macros/s/AKfycbwgl2GySobAnqmajBdzl6sxX18EYTbv4qeEukR6zJJ4AvzbRk44pHeXgu6vTJvwih3b/exec';
const SECRET = 'dreamstate';
const MAX_SECONDS = 30;

let mediaRecorder, audioStream, chunks = [];
let recordedBlob = null;
let timerInterval = null, seconds = 0;
const recordBtn = document.getElementById('recordBtn');
const pauseBtn = document.getElementById('pauseBtn');
const stopBtn = document.getElementById('stopBtn');
const resetBtn = document.getElementById('resetBtn');
const uploadBtn = document.getElementById('uploadBtn');
const player = document.getElementById('player');
const statusEl = document.getElementById('status');
const timerEl = document.getElementById('timer');

function updateTimer() {
  seconds++;
  if (seconds >= MAX_SECONDS) stopRecording();
  const mm = String(Math.floor(seconds / 60)).padStart(2,'0');
  const ss = String(seconds % 60).padStart(2,'0');
  timerEl.textContent = `${mm}:${ss} / 00:30`;
}

async function startRecording() {
  if (!navigator.mediaDevices || !navigator.mediaDevices.getUserMedia) {
    alert('getUserMedia not supported. Please use Safari or Chrome.');
    return;
  }
  try {
    audioStream = await navigator.mediaDevices.getUserMedia({ audio: true });
    const options = { mimeType: 'audio/webm' };
    mediaRecorder = new MediaRecorder(audioStream, options);
  } catch (err) {
    statusEl.textContent = 'Microphone access denied or unsupported: ' + err.message;
    return;
  }

  chunks = [];
  seconds = 0;
  timerEl.textContent = '00:00 / 00:30';
  timerInterval = setInterval(updateTimer, 1000);

  mediaRecorder.ondataavailable = e => {
    if (e.data && e.data.size > 0) chunks.push(e.data);
  };
  mediaRecorder.onstop = () => {
    recordedBlob = new Blob(chunks, { type: chunks[0] ? chunks[0].type : 'audio/webm' });
    player.src = URL.createObjectURL(recordedBlob);
    uploadBtn.disabled = false;
    resetBtn.disabled = false;
    pauseBtn.disabled = true;
    stopBtn.disabled = true;
    recordBtn.disabled = false;
    recordBtn.textContent = 'Record';
    statusEl.textContent = 'Recording ready. Play or upload.';
    if (audioStream) {
      audioStream.getTracks().forEach(t => t.stop());
      audioStream = null;
    }
    clearInterval(timerInterval);
  };

  mediaRecorder.start();
  statusEl.textContent = 'Recording...';
  recordBtn.textContent = 'Recording...';
  recordBtn.disabled = true;
  pauseBtn.disabled = false;
  stopBtn.disabled = false;
}

function pauseResume() {
  if (!mediaRecorder) return;
  if (mediaRecorder.state === 'recording' && mediaRecorder.pause) {
    mediaRecorder.pause();
    pauseBtn.textContent = 'Resume';
    clearInterval(timerInterval);
    statusEl.textContent = 'Paused';
  } else if (mediaRecorder.state === 'paused' && mediaRecorder.resume) {
    mediaRecorder.resume();
    pauseBtn.textContent = 'Pause';
    timerInterval = setInterval(updateTimer, 1000);
    statusEl.textContent = 'Recording...';
  }
}

function stopRecording() {
  if (mediaRecorder && (mediaRecorder.state === 'recording' || mediaRecorder.state === 'paused')) {
    mediaRecorder.stop();
  }
}

function resetRecording() {
  if (mediaRecorder && mediaRecorder.state !== 'inactive') {
    mediaRecorder.stop();
  }
  mediaRecorder = null;
  recordedBlob = null;
  chunks = [];
  player.src = '';
  uploadBtn.disabled = true;
  resetBtn.disabled = true;
  pauseBtn.disabled = true;
  stopBtn.disabled = true;
  recordBtn.disabled = false;
  recordBtn.textContent = 'Record';
  statusEl.textContent = '';
  timerEl.textContent = '00:00 / 00:30';
  clearInterval(timerInterval);
}

async function blobToBase64(blob) {
  return new Promise((resolve, reject) => {
    const reader = new FileReader();
    reader.onloadend = () => resolve(reader.result.split(',')[1]);
    reader.onerror = reject;
    reader.readAsDataURL(blob);
  });
}

async function upload() {
  if (!recordedBlob) return;
  statusEl.textContent = 'Preparing upload...';
  uploadBtn.disabled = true;

  try {
    const base64 = await blobToBase64(recordedBlob);
    const payload = {
      secret: SECRET,
      filename: 'recording_' + new Date().toISOString() + '.webm',
      mimeType: recordedBlob.type || 'audio/webm',
      data: base64
    };

    const res = await fetch(APP_URL, {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify(payload)
    });

    const json = await res.json();
    if (json.status === 'success') {
      statusEl.innerHTML = '‚úÖ Uploaded! <a href="' + json.url + '" target="_blank">Open in Drive</a>';
    } else {
      statusEl.textContent = 'Upload failed: ' + (json.message || JSON.stringify(json));
      uploadBtn.disabled = false;
    }
  } catch (err) {
    statusEl.textContent = 'Upload error: ' + err.message;
    uploadBtn.disabled = false;
  }
}

// Button actions
recordBtn.addEventListener('click', () => {
  if (!mediaRecorder || mediaRecorder.state === 'inactive') startRecording();
});
pauseBtn.addEventListener('click', pauseResume);
stopBtn.addEventListener('click', stopRecording);
resetBtn.addEventListener('click', resetRecording);
uploadBtn.addEventListener('click', upload);
</script>
</body>
</html>
